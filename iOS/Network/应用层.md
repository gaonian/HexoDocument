# 5. 应用层（Application）

应用层常见协议：

- 超文本传输

  HTTP、HTTPS

- 文件传输

  FTP

- 电子邮件

  SMTP、POP3、IMAP

- 动态主机配置

  DHCP

- 域名系统

  DNS

  

## 域名（Domin Name）

由于IP地址不方便记忆，并且不能表达组织的名称和性质，人们设计出了域名（比如baidu.com）

但实际上，为了能够访问到具体的主机，最终还是得知道目标主机的IP地址。

使用IP地址只占用4字节，可以减少路由器的负担，节省流量



根据级别不同，域名可以分为

- 顶级域名（Top-level Domain，简称TLD）
- 二级域名
- 三级域名
- 。。。



### 顶级域名

- 通用顶级域名（General Top-level Domain，简称gTLD）

  ```
  .com（公司）
  .net（网络机构）
  .org（组织结构）   
  .edu（教育）   
  .gov（政府部门）   
  .int（国际组织）
  ```

- 国家及地区顶级域名（Country Code Top-level Domain，简称ccTLD）

  ```
  .cn（中国）
  .jp（日本）
  .uk（英国）
  ```

- 新通用顶级域名（New Generic Top-level Domain，简称：New gTLD）

  ```
  .vip
  .xyz
  .top
  .club
  .shop
  ```

### 二级域名

二级域名是指顶级域名之下的域名

在通用顶级域名下，它一般指域名注册人的名称，例如google、baidu、microsoft等

在国家及地区顶级域名下，它一般指注册类别的，例如com、edu、gov、net等

![](./network_img/net_30.png)



## DNS

DNS的全程是：Domain Name System，译为：域名系统

利用DNS协议，可以将域名（比如baidu.com）解析成对应的IP地址（比如220.181.38.148）

DNS可以基于UDP协议，也可以基于TCP协议，服务器占用53端口

<img src="./network_img/net_31.png" style="zoom:75%;" />

客户端首先会访问最近的一台DNS服务器（也就是客户端自己配置的DNS服务器）

所有的DNS服务器都记录了DNS根域名服务器的IP地址

上级DNS服务器记录了下一级DNS服务器的IP地址

全球一共13台IPv4的DNS根域名服务器、25台IPv6的DNS根域名服务器



## DHCP

DHCP（Dynamic Host Configuration Protocol），译为：动态主机配置协议

DHCP协议基于UDP协议，客户端是68端口，服务器是67端口

DHCP服务器会从IP地址池中，挑选一个IP地址出租给客户端一段时间，时间到期就回收他们

平时家里上网的路由器就可以充当DHCP服务器

<img src="./network_img/net_32.png" style="zoom:37%;" />

![](./network_img/net_33.png)

分配IP地址的4个阶段

- DISCOVER：发现服务器

  发广播包（源IP是0.0.0.0，目标IP是255.255.255.255，目标MAC地址是FF:FF:FF:FF:FF:FF）

- OFFER：提供租约

  服务器返回可以租用的IP地址，以及租用期限、子网掩码、网关、DNS等信息

  注意：这里可能会有多个服务器提供租约

- REQUEST：选择IP地址

  客户端选择一个OFFER，发送广播包进行回应

- ACKNOWLEDGE：确认

  被选中的服务器发送ACK数据包给客户端

  至此，IP地址分配完毕



注意：

- DHCP服务器可以跨网段分配IP地址吗？（DHCP服务器、客户端不在同一个网段）

  可以借助DHCP中继代理（DHCP Relay Agent）实现跨网段分配IP地址

- 自动续约

  客户端会在租期不足的时候，自动向DHCP服务器发送REQUEST信息申请续约

- 常用命令

  - ipconfig /all 可以看到DHCP相关的详细信息，比如租约过期时间、DHCP服务器地址等
  - ipconfig /release  释放租约
  - ipconfig /renew   重新申请IP地址，申请续约（延长租期）



## telnet

可以直接面向HTTP报文与服务器交互

可以更清晰直观的看到请求报文、响应报文的内容

可以校验请求报文格式的正确与否

```
➜  ~ telnet localhost 80

Trying ::1...
Connected to localhost.
Escape character is '^]'.
GET /index.html HTTP/1.1
Host: localhost:80

HTTP/1.1 200 OK
Date: Wed, 09 Dec 2020 14:05:32 GMT
Server: Apache/2.4.41 (Unix)
Last-Modified: Tue, 08 Dec 2020 14:55:46 GMT
ETag: "143-5b5f523376080"
Accept-Ranges: bytes
Content-Length: 323
Content-Type: text/html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>

    <p>hello world!!!</p>

    <button onclick="buttonClick()">button</button>
    
</body>

<script>
    function buttonClick() {
        window.location.href = "https://www.baidu.com";
    }
</script>


</html>Connection closed by foreign host.
```



## HTTP

HTTP（HyperText Transfer Protocol）超文本传输协议

- HTTP是一个在计算机世界里专门在两点之间传输文本、图片、音频、视频等超文本数据的约定和规范

- 互联网中应用最广泛的应用层协议之一
- 设计最初目的是：提供一种发布和接收HTML页面的方法，由URI来标识具体的资源



1. HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；
2. HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
3. HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
4. HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
5. HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。



1. HTTP 最大的优点是简单、灵活和易于扩展；
2. HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；
3. HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；
4. HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
5. HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；
6. HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。



### 发展历史

- 1991年，HTTP/0.9

  只支持GET请求方法获取文本数据（比如HTML文档），且不支持请求头，响应头等，无法向服务器传递太多信息

- 1996年，HTTP/1.0

  支持POST HEAD等请求方法，支持请求头、响应头等，支持更多种数据类型（不再局限于文本数据）

  浏览器的每次请求都需要与服务器建立一个TCP连接，请求处理完成后立即断开TCP连接

- 1997年，HTTP/1.1 （最经典，使用最广泛的版本）

  支持PUT  DELETE等请求方法

  采用持久连接（Connection：keep-alive），多个请求可以共用同一个TCP连接

- 2015年，HTTP/2.0

  HTTP/2 基于Google的SPDY协议，注重性能改善，但还未普及

- 2018年，HTTP/3.0

  HTTP/3 基于Google的QUIC协议，是将来的发展方向

### 报文格式

![](./network_img/net_34.png)

```
GET / HTTP/1.1
Host: localhost
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.67 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
If-None-Match: "143-5b5f523376080"
If-Modified-Since: Tue, 08 Dec 2020 14:55:46 GMT

实体主体，若是POST，则此部分放参数（username=123&pwd=456）
```



![](./network_img/net_35.png)

```
HTTP/1.1 200 OK
Date: Tue, 08 Dec 2020 15:01:40 GMT
Server: Apache/2.4.41 (Unix)
Last-Modified: Tue, 08 Dec 2020 14:55:46 GMT
ETag: "143-5b5f523376080"
Accept-Ranges: bytes
Content-Length: 323
Content-Type: text/html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>

    <p>hello world!!!</p>

    <button onclick="buttonClick()">button</button>
    
</body>

<script>
    function buttonClick() {
        window.location.href = "https://www.baidu.com";
    }
</script>


</html>
```

### ABNF

ABNF（Augmented BNF）是BNF 的修改增强版

在[RFC 5234](https://tools.ietf.org/html/rfc5234) 中表明：ABNF用作internet中通信协议的定义语言

ABNF是最严谨的HTTP报文格式描述形式，脱离ABNF谈论HTTP报文格式，往往都是片面 不严谨的

[HTTP报文格式的定义](https://tools.ietf.org/html/rfc7230%23section-3)



#### 1. 报文格式 - 整体

``` 
HTTP-message = start-line
							 *(header-field CRLF)
							 CRLF
							 [ message-body ]
```

| /    | 任选一个                                     |
| ---- | -------------------------------------------- |
| *    | 0个或多个。 `2*表示至少2个`，`3*6表示3到6个` |
| ()   | 组成一个整体                                 |
| []   | 可选（可有可无）                             |

- **start-line**

  表示 request-line / status-line 中的任意一个

- `*(header-field CRLF)`

  表示首部行，可以没有，可以有多个，key：value形式表示，每一行结尾有回车换行

- **CRLF**

  表示回车换行

- **[ message-body ]**

  可选项。如果是post请求，请求参数放在此 （ username=123&pwd=456 ）

  

#### 2. request-line / status-line

1. **request-line:**

   ```
   request-line = method SP request-target SP HTTP-version CRLF
   
   HTTP-version = HTTP-name"/"DIGIT"."DIGIT
   
   HTTP-name = %x48.54.54.50   ;HTTP
   ```
   
   对应的请求行为   
   
   ```
   GET /hello/ HTTP/1.1
   ```
   
2. **status-line:**

   ```
   status-line = HTTP-version SP status-code SP reason-phrase CRLF
   
   status-code = 3DIGIT    ;表示3位数字
   
   reason-phrase = *(HTAB / SP / VCHAR / obs-text)
   ```

   代表的响应行为

   ```
   HTTP/1.1 200 
   HTTP/1.1 200 OK
   ```

     

#### 3. header-field

```
header-field = field-name":" OWS field-value OWS

field-name = token

field-value = *(field-content / obs-fold)
```

OWS表示 `*(SP / HTAB)`，可以为空格或者tab键

```
Host: localhost
```



#### 4. message-body

```
message-body = *OCTET

username=123&pwd=456
```



### 请求方法

[Request methods](https://tools.ietf.org/html/rfc7231%23section-4) 中描述了8中请求方法

```
GET  HEAD  POST  PUT  DELETE  CONNECT  OPTIONS  TRACE
```

[Patch method](https://tools.ietf.org/html/rfc5789%23section-2) 中描述了PATCH方法

- **GET**

  常用于读取的操作，请求参数直接拼接在URL的后面（浏览器对URL是有长度限制的）

- **HEAD**

  请求得到与GET请求相同的响应，但是没有响应体

  在下载一个大文件前，可以先获取其大小，再决定是否要下载。以此节约带宽资源

- **POST**

  常用于添加、修改、删除的操作，请求参数可以放到请求体中（没有大小限制）

- **PUT**

  用于对已存在的资源进行整体覆盖

- **DELETE**

  用于删除指定的资源

- **CONNECT**

  可以开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道（tunnel）

  可以用来访问采用了SSL（HTTPS）协议的站点

- **OPTIONS**

  用于获取目的资源所支持的通信选项，比如服务器支持的请求方式
  
  ```
  OPTIONS * HTTP/1.1
  ```

- **TRACE**

  请求服务器回显其收到的请求信息，主要用于HTTP请求的测试或诊断

- **PATCH**

  用于对资源进行部分修改（资源不存在，会创建新的资源）



### URI

URI（Uniform Resource Identifier）统一资源标识符

![](./network_img/net_38.png)





### HTTP首部字段

#### 通用首部字段（General Header Fields）

请求报文和响应报文两方都会使用的首部

- **Cache-Control**

  控制缓存的行为。用来指定在这次的请求、响应链中的所有缓存机制都必须遵守的指令

  ```
  Cache-Control: max-age=5
  ```

  - **max-age**

    响应的最大age值，单位是秒。max-age=0通常与no-cache表达意思一样。都是想服务器获取最新资源

  - **no-store**

    不允许缓存，强制向源服务器再次验证。用于某些变化非常频繁的数据，例如秒杀页面；

  - **no-cache**

    它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是**可以缓存**，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；

- **Connection**

  该浏览器想要优先使用的连接类型，HTTP/1.1中的连接都会默认使用长连接

  ```
  Connection: keep-alive
  ```

  在客户端，可以在请求头里加上“**Connection: close**”字段，告诉服务器：“这次通信后就关闭连接”。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。

  ```
  Connection: close
  ```

- **Date**

  发送该消息的日期和时间

  ```
  Date: Wed, 09 Dec 2020 14:30:01 GMT
  ```

- **Pragma**

  报文指令

- **Trailer**

  报文末端的首部一览

- **Transfer-Encoding**

  首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。 HTTP/1.1 的传输编码方式仅对 **分块传输** 编码有效。意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。

  ```
  HTTP/1.1 200 OK
  Date: Tue, 03 Jul 2012 04:40:56 GMT 
  Cache-Control: public, max-age=604800 
  Content-Type: text/javascript; charset=utf-8 
  Expires: Tue, 10 Jul 2012 04:40:56 GMT  
  Content-Encoding: gzip
  ...
  Transfer-Encoding: chunked
  ...
  Connection: keep-alive
  
  cf0 ←16进制(10进制为3312) 
  ...3312字节分块数据...
  392 ←16进制(10进制为914) 
  ...914字节分块数据...
  0
  ```

  以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效 使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块数据。

  1. 每个分块包含两个部分，长度头和数据块；
  2. 长度头是以 CRLF（回车换行，即\r\n）结尾的一行明文，用 16 进制数字表示长度；
  3. 数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不包含 CRLF；
  4. 最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”。

  <img src="./network_img/net_39.png" style="zoom:30%;" />

- **Upgrade**

  升级为其他协议

- **Via**

  代理服务器的相关信息

- **Warning**

  错误通知



#### 请求首部字段（Request Header Fields）

从客户端向服务端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息

- **Accept**

  能够接受的响应内容类型（Content-Types）

  ```
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
  ```

  `;q=0.9` 代表权重值，用；进行分割。权重值q的范围为0-1（可精确到小数点后3位），且1为最大值。不指定权重q值时，默认为q=1.0

  - 文本文件

  ```
    text/html, text/plain, text/css ... 
    application/xhtml+xml, application/xml ...
  ```

  - 图片文件

    ```
    image/jpeg, image/gif, image/png ...
    ```

  - 视频文件

    ```
    video/mpeg, video/quicktime ...
    ```

  - 应用程序使用的二进制文件

    ```
    application/octet-stream, application/zip ...
    ```

- **Accept-Charset**

  能够接受的字符集

  ```
  Accept-Charset: utf-8
  ```

- **Accept-Encoding**

  能够接受的编码方式列表

  ```
  Accept-Encoding: gzip, deflate, br
  ```

  - **gzip**

    由文件压缩程序 gzip(GNU zip)生成的编码格式 (RFC1952)，采用 Lempel-Ziv 算法(LZ77)及 32 位循环冗余 校验(Cyclic Redundancy Check，通称 CRC)。互联网上最流行的压缩格式

  - **deflate**

    组合使用 zlib 格式(RFC1950)及由 deflate 压缩算法 (RFC1951)生成的编码格式。流行程度仅次于gzip

  - **br**

    一种专门为HTTP优化的新压缩算法（Brotli）

  - **compress**

    由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel- Ziv-Welch 算法(LZW)。

  - **identity**

    不执行压缩或不会变化的默认编码格式

  采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另外，也可使用星号(*)作为通配符，指定任意的编码格式。

- **Accept-Language**

  能够接受的响应内容的自然语言列表

  ```
  Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
  ```

- **Authorization**

  web认证信息。用来告知服务器，用户代理的认证信息(证 书值)。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中

  ```
  Authorization: Basic dWVub3NlbjpwYXNzd29yZA==
  ```

- **Expect**

  期待服务器的特定行为

- **From**

  用户的电子邮箱地址

- **Host**

  服务器的域名、端口号

  ```
  Host: www.baidu.com
  ```

- **User-Agent**

  浏览器的身份标识字符串

  ```
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.67 Safari/537.36
  ```

- **Referer**

  标识浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面

  假设在我们本地的页面上点击一个按钮跳转到百度，此时在请求百度页面就会看到Referer字段

  ```
  Referer: http://localhost/
  ```

- **Range**

  对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。下面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。

  接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状 态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返 回状态码 200 OK 的响应及全部资源。

  ```
  Range: bytes=5001-10000
  ```

- **Origin**

  发起一个针对跨域资源共享的请求

  ```
  Origin: https://www.baidu.com
  ```

- **Cookie**

  之前由服务器通过Set-Cookie发送的Cookie

  ```
  Cookie: BIDUPSID=43F64A06F72D2A56E7FC0274274187DB;
  ```

- **If-Match**

  形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。

  ```
  If-Match: "123456"
  ```

  首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记(ETag)值。这时的服务器无法使用弱 ETag 值。

  服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响 应。

  还可以使用星号(`*`)指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。

  ```
  If-Match: *
  ```

- **If-Modified-Since**

  如果在 **If-Modified-Since** 字段指定的日期时间后，资源发生了 更新，服务器会接受请求

  ```
  If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT
  ```

  首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。 而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。

  If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。 获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。

- **If-None-Match**

  ```
  If-None-Match: "143-5b5f523376080"
  ```

  只有在 **If-None-Match** 的字段值与 **ETag** 值不一致时，可处理该请求。与 **If-Match** 首部字段的作用相反

  首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记(ETag)值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。

  在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。

- **If-Range**

  首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值(ETag 值或者时间)和请求资源的 ETag 值或时间相一 致时，则作为范围请求处理。反之，则忽略范围请求，返回全体资源。

  ```
  If-Range: "123456"
  Range: bytes=5001-10000
  ```

- **If-Unmodified-Since**

  ```
  If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT
  ```

  首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相 反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。



#### 响应首部字段（Response Header Fields）

从服务端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息

- **Accept-Ranges**

  首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请 求，以指定获取服务器端某个部分的资源。

  可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则 指定其为 none。

  ```
  Accept-Ranges: bytes
  ```

- **Location**

  使用首部字段Location可以将响应接收方引导至某个与请求URI位置不同的资源

  基本上，该字段会配合 3xx：Redirection的响应，提供重定向的URI。几乎所有的浏览器在接收到包含首部字段Location的响应后，都会强制性的尝试对已提示的重定向资源的访问

  ```
  Location: http://www.w3.org
  ```

- **Proxy-Authenticate**

  代理服务器对客户端的认证信息。首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送 给客户端。

  它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在 于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间 进行认证时，首部字段 WWW-Authorization 有着相同的作用

  ```
  Proxy-Authenticate: Basic realm="Usagidesign Auth"
  ```

- **Server**

  服务器的名字

  ```
  Server: BWS/1.1
  Server: Apache/2.4.1 (Unix)
  ```

- **Vary**

  代理服务器缓存的管理信息

- **WWW-Authenticate**

  服务器对客户端的认证信息

  ```
  WWW-Authenticate: Basic realm="Usagidesign Auth"
  ```

- **Access-Control-Allow-Origin**

  指定哪些网站可参与到跨来源资源共享过程中

  ```
  Access-Control-Allow-Origin: *
  ```

- **ETag**

  ```
  ETag: "143-5b5f523376080"
  ```

  ETag 是“实体标签”（Entity Tag）的缩写，**是资源的一个唯一标识**，它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。

  另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。

  使用 ETag 就可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存。

  - 强 ETag 值

    不论实体发生多么细微的变化都会改变其值。

    ```
    ETag: "143-5b5f523376080"
    ```

  - 弱 ETag 值

    弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。（例如 HTML 里的标签顺序调整，或者多了几个空格）

    ```
    ETag: W/"143-5b5f523376080"
    ```

- **Set-Cookie**

  Cookie 最基本的用途是身份识别，实现有状态的会话事务。返回一个Cookie让客户端去保存。当服务器准备开始管理客户端状态时，会事先告知各种信息

  Cookie并不属于HTTP标准。使用的分隔符是`;` ，并不是 `,` 

  ```
  Set-Cookie: H_PS_PSSID=33213_1460_33225_33119_33060_33113_33098_33101_33183_33181_32845_33199_33237_33217_33216_33215_33185; path=/; domain=.baidu.com
  ```

  | 属性         | 说明                                                         |
  | ------------ | ------------------------------------------------------------ |
  | NAME=VALUE   | 赋予Cookie的名称和值                                         |
  | expires=DATE | Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）       |
  | path=PATH    | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录） |
  | domain=域名  | 作为Cookie适用对象的域名（若不指定默认为创建Cookie的服务器的域名） |
  | Secure       | 仅在HTTPS安全通信前才会发送Cookie                            |
  | HttpOnly     | 加以限制，使Cookie不能被JavaScript脚本访问                   |



#### 实体首部字段（Entity Header Fields）

针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息

- **Allow**

  资源可支持的HTTP方法

  ```
  Allow: GET, HEAD
  ```

- **Last-Modified**

  所请求的对象的最后修改日期

  ```
  Last-Modified: Wed, 09 Dec 2020 14:30:01 GMT
  ```

- **Expires**

  指定一个时间，超过该时间则认为此响应以及过期

  ```
  Expires: Wed, 09 Dec 2020 14:30:01 GMT
  ```

- **Content-Type**

  响应体的类型

  ```
  Content-Type: text/html;charset=utf-8
  
  Content-Type: multipart/form-data;boundary=xxx
  ```

- **Content-Encoding**

  内容所使用的编码类型

  ```
  Content-Encoding: gzip
  ```

- **Content-Length**

  响应体的长度（字节为单位）

  ```
  Content-Length: 348
  ```

- **Content-Disposition**

  一个可以让客户端下载文件并建议文件名的头部

  ```
  Content-Disposition: attachment; filename="fname.ext"
  ```

- **Content-Range**

  这条部分消息是属于完整消息的哪部分

  ```
  Content-Range: bytes 21010-47021/47022
  ```



### HTTP状态码（Status Code）

在[RFC 2616 10.Status Code Definitions](https://tools.ietf.org/html/rfc2616%23section-10)规范中定义。状态码指示HTTP请求是否已成功完成

状态码可以分为5类

- 信息响应：100~199
- 成功响应：200~299
- 重定向：300~399
- 客户端错误：400~499
- 服务器错误：500~599



#### 1xx（信息）

1xx表示接收的请求正在处理

- 100 Continue

  请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应该继续发送剩余的请求，如果请求已经完成，就忽略这个响应。

  允许客户端发送带请求头的请求前，判断服务器是否愿意接收请求（服务器通过请求头判断）

  在某些情况下，如果服务器在不看请求头就拒绝请求时，客户端就发送请求体是不恰当的或低效的



#### 2xx（成功）

2xx的响应结果表明请求被正常处理了

- **200 OK**

  表示从客户端发来的请求在服务器端被正常处理了。

  在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返 回; 而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回(即在响应中只返回首部，不会返回实体的主体部 分)。

- **204 No Content**

  该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如， 当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。

  一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。

- **206 Partial Content**

  该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。



#### 3xx（重定向）

3xx 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

- **301 永久重定向（ Moved Permanently）**

  永久性重定向。该状态码表示请求的资源已被分配了新的 URI，今后所有的请求都必须改用新的 URI。

  浏览器看到 301，就知道原来的 URI“过时”了，就会做适当的优化。比如历史记录、更新书签，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本。搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI。

- **302 临时重定向（ Moved Temporarily）**

  临时性重定向。意思是原 URI 处于“临时维护”状态，新的 URI 是起“顶包”作用的“临时工”。希望用户(本次)能使用新的 URI 访问。

  浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效，但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI。

  和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码 的页面对应的 URI。

- **303 See Other**

  该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

  303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。

  比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望 客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303状态码是最理想的

- **304 Not Modified**

  该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。

  说明无需再次传输请求的内容，也就是说可以使用缓存的内容
  
- **307 Temporary Redirect**

  类似 302，但重定向后请求里的方法和实体不允许变动，含义比 302 更明确；

- **308 Permanent Redirect**

  类似 307，不允许重定向后的请求变动，但它是 301“永久重定向”的含义。



#### 4xx（客户端错误）

4xx 的响应结果表明客户端是发生错误的原因所在。

- **400 Bad Request**

  该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

- **401 Unauthorized**

  该状态码表示发送的请求需要有通过 HTTP 认证的认证信息。

  返回含有 401 的响应必须包含一个适用于被请求资源的 WWW- Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收 到 401 响应，会弹出认证用的对话窗口。

- **403 Forbidden**

  该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。 

  未获得文件系统的访问授权，访问权限出现某些问题(从未授权的发送源 IP 地址试图访问)等列举的情况都可能是发生 403 的原因。

- **404 Not Found**

  该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

- **405 Method Not Allowed**

  服务器禁止了使用当前HTTP方法的请求。例如不允许使用GET请求，需要换成POST

- **406 Not Acceptable**

  服务器无法提供与Accept-Charset以及Accept-Language指定的值相匹配的响应

- **408 Request Timeout**

  服务器想要将没有在使用的连接关闭。一些服务器会在空闲连接上发送此消息，即便是在客户端没有发送任何请求的情况下



#### 5xx（服务器错误）

5xx 的响应结果表明服务器本身发生错误。

- **500 Internal Server Error**

  该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。

- **501 Not Implemented**

  请求的方法不被服务器支持，因此无法被处理。服务器必须支持的方法（即不会返回这个状态码的方法）只有 GET 和 HEAD

- **502 Bad Gateway**

  作为网关或代理角色的服务器，从上游服务器（如tomcat）中接收到的响应是无效的

- **503 Service Unavailable**

  该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。